#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = 'joao'

import numpy as np
import os
import csv
from PIL import Image
from collections import Iterable


class IterableException(Exception):
    pass


class FileNotFoundException(Exception):
    pass


class GraphInterpreter(object):

    """
    Graphic Interpreter object, the class is
    responsible to deal with subsets of the image
    generated by CPTEC. This class crops the desired
    graphic by it's type and can understand what's being
    shown in it.
    """

    base_dir = os.path.abspath(os.path.dirname(__file__)).replace('image_analyser', 'data')
    data_types = {"rain": (49, 40, 565, 132),
                  "temp": (49, 168, 565, 260),
                  "humidity": (49, 295, 565, 387)
                  }

    def __init__(self, img_path, data_range, data_type):
        """
        :param img_path: "<city_name>/<city_name_with_date>"
        :param data_range: minimum and maximum value of graph
        :param data_type: choice between "rain", "temp" and "humidity"
        :type img_path: str
        :type data_range: Iterable
        :type data_type: str
        """

        if os.path.exists('data/{}'.format(img_path)):
            self.img_path = 'data/{}'.format(img_path)
        else:
            raise FileNotFoundException("the image file wasn't found")

        if isinstance(data_range, Iterable) and len(data_range) == 2:
            self.data_range = data_range
        else:
            raise IterableException("data_range must a list or tuple with"
                                    " 2 values, min_value and max_value")
        self.data_type = self.data_types[data_type]
        self.data_type_name = data_type

    def crop_image(self):
        """
        Crops the image by it's type.

        :returns: PIL.Image._ImageCrop
        """

        image_data = Image.open(self.img_path)
        return image_data.crop(self.data_type)

    def np_image_matrix(self):
        """
        Transform cropped imagem into numpy
        array

        :returns: numpy array
        :rtype: numpy.ndarray
        """
        return np.array(self.crop_image())

    def blue_matrix(self):
        """
        find the blue pixels and it's indexes

        :returns: numpy array
        :rtype: numpy.ndarray
        """
        return np.vstack(np.where(self.np_image_matrix() == 2))

    def get_days_index(self):
        """
        find the gray pixels and it's indexex

         :returns: numpy array
         :rtype: numpy.ndarray
        """
        return np.where(self.np_image_matrix()[3] == 3)[0]

    def clean_double_values(self):
        trans_blue = self.blue_matrix().transpose()
        b_array = []
        for i in trans_blue:
            min_col = [i[0], i[1]]
            for j in trans_blue[0:]:
                if j[1] == min_col[1]:
                    if j[0] < min_col[0]:
                        min_col[0] = j[0]
            if min_col not in b_array:
                b_array.append(min_col)

        return sorted(b_array, key=lambda i: i[1])

    def calculate_data_value(self, single_val):
        y_pixel_range = float(self.data_type[3] - self.data_type[1] - 2)
        data = round((max(self.data_range) - (single_val * (max(self.data_range) - min(self.data_range))/y_pixel_range)), ndigits=2)
        return data

    def values_of_day(self):
        for i in range(11):
            lista = []
            for j in self.clean_double_values():
                if self.get_days_index()[i+1] > j[1] >= self.get_days_index()[i]:
                    lista.append(self.calculate_data_value(j[0].item()))
            if not self.data_type_name == 'rain':
                yield lista
            else:
                yield [sum(lista)]

    def save_values(self):
        f_name = self.img_path.split('.')[0] + '_{}_'.format(self.data_type_name) + '.csv'
        dir_name = os.path.join(self.base_dir, f_name)
        if not os.path.exists(dir_name):
            for data_list in self.values_of_day():
                with open(f_name, 'a') as f:
                    wr = csv.writer(f)
                    wr.writerow(data_list)
        else:
            os.remove(f_name)
            for data_list in self.values_of_day():
                with open(f_name, 'a') as f:
                    wr = csv.writer(f)
                    wr.writerow(data_list)