#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
.. module:: image_analyser.img_analyser
    :platform: Unix, Osx, Windows

.. moduleauthor:: Joao Trevizoli Esteves<joao@lab804.com.br>
"""

import numpy as np
import os
import csv

from PIL import Image
from collections import Iterable

__author__ = 'joao'


class IterableException(Exception):
    """Iterable Exceptions

    Raises exceptions for iterable

    :raises: Iterable Exception
    """
    pass


class FileNotFoundException(Exception):
    """ File Exceptions

    Raises File exceptions when trying to open
    an invalid image.

    :raises: FileNotFound Exception
    """
    pass


class GraphInterpreter(object):

    """
    Graphic Interpreter object, the class is
    responsible to deal with subsets of the image
    generated by CPTEC. This class crops the desired
    graphic by it's type and can understand what's being
    shown in it.

    .. note::
        In this version of the software it's only being considered
        as relevant:
            * Amount of Rain
            * Temperature Variation
            * Humidity Variation


    :param: img_path: "<city_name>/<city_name_with_date>"
    :param: data_range: minimum and maximum value of graph
    :param: data_type: choice between "rain", "temp" and "humidity"
    :type: img_path: str
    :type: data_range: Iterable
    :type: data_type: str
    """

    base_dir = os.path.abspath(os.path.dirname(__file__)).\
        replace('image_analyser', 'data')

    data_types = {"rain": (49, 40, 565, 132),
                  "temp": (49, 168, 565, 260),
                  "humidity": (49, 295, 565, 387)
                  }

    def __init__(self, img_path, data_range, data_type):
        print os.path.abspath('data/{}'.format(img_path))

        if os.path.exists('data/{}'.format(img_path)):
            self.img_path = 'data/{}'.format(img_path)
        else:
            raise FileNotFoundException("the image file wasn't found")

        if isinstance(data_range, Iterable) and len(data_range) == 2:
            self.data_range = data_range
        else:
            raise IterableException("data_range must a list or tuple with"
                                    " 2 values, min_value and max_value")
        self.data_type = self.data_types[data_type]
        self.data_type_name = data_type

    def crop_image(self):
        """ Crop graph image

        Crops the desired image by it's type.

        :returns: PIL.Image._ImageCrop
        """

        image_data = Image.open(self.img_path)
        return image_data.crop(self.data_type)

    def np_image_matrix(self):
        """Transform Image into array

        Transform cropped image into an
        numpy multidimensional array.

        :returns: numpy array
        :rtype: numpy.ndarray
        """
        return np.array(self.crop_image())

    def blue_matrix(self):
        """ Find Blue pixels

        Finds all blue pixels inside the graph area,
        which represents the desired points of the graph.

        The method generates a numpy 2d array with these
        pixels relative positions.

        :returns: numpy array of blue pixels
        :rtype: numpy.ndarray
        """
        return np.vstack(np.where(self.np_image_matrix() == 2))

    def get_days_index(self):
        """
        find the gray pixels and it's indexex

         :returns: numpy array with days range
         :rtype: numpy.ndarray
        """
        return np.where(self.np_image_matrix()[3] == 3)[0]

    def clean_double_values(self):
        """ clean repeated j pixels

        Find the first item of each row and gets the
        pixels with the lowest j value, which represents
        the biggest real value of the y axis of the graph,
        crossed with x axis.

        :returns: matrix of blue pixels
        :rtype: list
        """
        trans_blue = self.blue_matrix().transpose()
        b_array = []
        for i in trans_blue:
            min_col = [i[0], i[1]]
            for j in trans_blue[0:]:
                if j[1] == min_col[1]:
                    if j[0] < min_col[0]:
                        min_col[0] = j[0]
            if min_col not in b_array:
                b_array.append(min_col)

        return sorted(b_array, key=lambda i: i[1])

    def calculate_data_value(self, single_val):
        """Calculates singel pixel value

        Calculates the numeric value of
        each pixel, with two digits precision\

        :param: single_val: y pixel position
        :returns: float value of pixel
        :rtype: float
        """
        y_pixel_range = float(self.data_type[3] - self.data_type[1] - 2)
        data = round((max(self.data_range) -
                      (single_val * (max(self.data_range) -
                                     min(self.data_range))/y_pixel_range
                       )
                      ), ndigits=2)
        return data

    def converted_values(self):
        """ Convert pixels j values

        Converts all j pixel day values to numeric
        real values, based on the the type of data and
        the range submitted.

        :returns: generator of each day value
        :rtype: Iterable
        """
        for i in range(11):
            lista = []
            for j in self.clean_double_values():
                if self.get_days_index()[i+1] > j[1] >= \
                        self.get_days_index()[i]:
                    lista.append(self.calculate_data_value(j[0].item()))
            if not self.data_type_name == 'rain':
                yield lista
            else:
                yield [sum(lista)]

    def save_values(self):
        """Saves csv file into image folder


        saves generated data by class into a
        csv file with the name, plus the type of data.
        This method keeps track if the file was generate,
        and replace it with a new one

        :returns: csv file
        :rtype: file
        """
        f_name = self.img_path.split('.')[0] + '_{}_'.\
            format(self.data_type_name) + '.csv'
        dir_name = os.path.join(self.base_dir, f_name)
        if not os.path.exists(dir_name):
            for data_list in self.converted_values():
                with open(f_name, 'a') as f:
                    wr = csv.writer(f)
                    wr.writerow(data_list)
        else:
            os.remove(f_name)
            for data_list in self.converted_values():
                with open(f_name, 'a') as f:
                    wr = csv.writer(f)
                    wr.writerow(data_list)
